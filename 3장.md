[하준](https://www.notion.so/3-d20f911cb27c45608a2d15d67f49457c)
## 코틀린 컬렉션
    
    set : hashSetOf
    
    list : arrayListOf
    
    map : hashMapOf
    

## 디폴트 파라미터 값
    
    함수의 디폴트 파리미터 값은 함수를 호출하는 쪽이 아니라 함수 선언쪽에 지정된다.
    
    코틀린 함수를 자바에서 호출하는 경우에는 모든 인자를 명시해야한다.
    

## 최상위 프로퍼티
    
    최상위 프로퍼티도 접근자 메소드를 통해 자바 코드에 노출된다.
    
    const변경자를 추가하면 프로퍼티를 public static final 필드로 컴파일하게 만들 수 있다.(원사타입과 String타입일 경우에만)
    

## 확장 함수
    
    확장함수를 만들려면 추가하려는 함수 이름 앞에 그 함수가 확장할 클래스의 이름을 덧붙이면 된다.
    
    클래스이름 : 수신 객체 타입
    
    확장 함수가 호출되는 대상이 되는 값 : 수신 객체
    
    일반 메소드와 마찬가지로 확장함수 본문에서도 this를 생략할 수 있다.
    
    확장 함수 안에서는 클래스 내부에서만 사용할 수 있는 비공개 멤버나 보호된 멤버를 사용할 수없다.
    

## 임포트와 확장함수
    
    코틀린에서는 클래스를 임포트 할때와 동일한 구문을 사용해 개별함수를 임포트할 수 있다.
    
    as 키워드를 사용하면 다른 이름으로 부를 수 있다.
    
    코틀린 문법상 확장함수는 반드시 짧은 이름을 써야한다.
    

## 확장 함수로 유틸리티 함수 정의
    
    확장 함수는 단지 정적 메소드 호출에 대한 문법적인 편의일 뿐이다.
    
    클래스가 아닌 더 구체적인 타입을 수신 객체 타입으로 지정할 수 있다.
    
    <T> → <String>
    

## 확장함수는 오버라이드 할 수 없다(코틀린은 호출될 확장 함수를 정적으로 결정하기 때문)
    
    정적 : 컴파일 시점
    
    동적 : 실행 시점
    
    확장 함수는 클래스 밖에 선언된다.
    
    확장함수를 호출할 때 수신 객체로 지정한 변수의 정적 타입에 의해 어떤 확장 함수가 호출될지 결정될지, 그 변수에 저장된 객체의 동적인 타입에 의해 확장 함수가 결정되지 않는다.
    
    확장 함수를 첫번째 인자가 수신객체인 정적 자바 메소드로 컴파일한다는 사실을 기억한다면 이런 동작을 쉽게 이해할 수 있다.
    
    확장한 함수와 멤버 함수의 이름과 시그니처가 같다면 멤버함수가 호출된다.(멤버함수의 우선순위가 더 높기 때문)
    

## 확장 프로퍼티
    
    뒷받침하는 필드가 없어서 최소한 게터는 꼭 정의해야한다.
    
    계산할 값을 담을 장소가 전혀 없으므로 초기화 코드도 쓸수 없다.
