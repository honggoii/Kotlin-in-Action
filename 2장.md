[하준](https://www.notion.so/2-c945dc261a314783a221cca9ab9767ce)
# 기본요소 : 함수와 변수

## 함수
    
    함수를 선언할때는 fun키워드를 사용한다.
    
    파라미터 이름 뒤에 그 파라미터와 타입을 쓴다.
    
    함수를 최상위 수준에 정의 할 수 있다.
    
    코틀린에서는 배열 처리를 위한 문법이 따로 존재하지 않는다.
    
    코틀린 표준 라이브러리는 여러가지 표준 자바 라이브러리 함수를 간결하게 사용할 수 있게 감싼 레퍼를 제공한다.
    
    세미콜론을 붙이지 않아도 된다.
    
## 식이 본문이 함수
    
    코틀린에서는 if는 식이지 문이 아니다.(식은 값을 만들어 내며 다른 식의 하위요소로 계산에 참여할 수 있다.)
    
    대입문은 자바에서 식이었으나 코틀린에서는 문이 됐다.
    
    함수에서 중괄호를 없애고 return을 제거하면서 등호를 식 앞에 붙이면 더 간결하게 함수를 표현할 수 있다.(식이 본문인 함수)
    
    식이 본문인 함수는 굳이 반환타입을 적지 않아도 컴파일러가 식의 결과 타입을 함수 반환 타입으로 정해준다.
    
    식이 본문인 함수의 반환 타입만 생략 가능하다. 블록이 본문인 함수는 반환타입을 지정하고 return문을 사용해야한다.
    
## 변수
    
    val - 변경 불가능한 참조를 저장하는 변수. 재대입이 불가능하다.(자바에서는 final변수에 해당)
    
    var - 변경 가능한 참조를 저장하는 변수. 재대입이 가능하다.(자바에서는 일반변수에 해당)
    
    기본적으로 val키워드를 사용해 불변 변수로 선언하고, 나중에 꼭 필요할 때만 var로 변경하는 것이 좋다.
    
    val 참조 자체는 불변이라도 그 참조가 가리키는 객체의 내부 값을 변경될 수 있다.
  
    var 변수는 값을 변경할 수 있지만, 변수의 타입은 고정돼 바뀌지 않는다.
    
## 문자열 템플릿
    
    변수 앞에 $를 추가하여 사용한다.
    
    $ 문자를 문자열에 넣고 싶으면 \를 사용해 $를 이스케이프 시켜야한다.
    
    중괄호로 둘러싼 식 안에서 큰 따옴표를 사용할 수도 있다.
    
## 클래스
    
    클래스는 데이터를 캡슐화하고 캡슐화된 데이터를 다루는 코드를 한 주체 아래에 가두는 것이 목적
    
    값 객체 - 코드가 없이 데이터만 저장하는 클래스
    
    코틀린의 기본 가시성은 public이다.
    

## 프로퍼티
    
    자바에서 데이터를 필드에 저장하며, 멤버 필드의 가시성은 보통 비공개여서 접근자 메소드를 제공한다(게터, 세터)
    
    자바에서는 필드와 접근자를 한데 묶어 프로퍼티라 한다.
    
    코틀린에서는 프로퍼티를 언어 기본 기능으로 제공한다.
    
    val로 선언한 프로퍼티는 읽기 전용이며, var로 선언한 프로퍼티는 변경가능이다.
    
    대부분의 프로퍼티는 그 프로퍼티 값을 저장하기 위한 필드가 있는데 뒷받침하는 필드라고 부른다. 커스텀 게터를 작성하면 프로퍼티 값을 원할때마다 계산할 수 있다.
    

## 선택과 표현과 처리 : enum과 when
    
    코틀린에서 enum은 소프트 키워드라 부르는 존재다.
    
    enum클래스 안에도 프로퍼티나 메소드를 정의할 수 있다.
    
    enum클래스 안에 메소드를 정의하는 경우 반드시 enum상수 목록과 메소드 정의 사이에 세미콜론을 넣어야한다.
    
    자바에서 switch는 코틀린에서 when이다.
    
    식이 본문인 함수에 when을 바로 사용할 수 있다.
    
    when의 분기 조건부분에 식을 넣을 수 있기 때문에 많은 경우 코드를 더 간결하고 아릅답게 작성할 수 있다.
    
    when에 아무 인자가 없으려면 각 분기의 조건이 불리언 결과를 계산하는 식이여야한다.
    

## 스마트 캐스트 : 타입 검사와 타입 캐스트를 조합
    
    코틀린에서는 is를 사용해 변수 타입을 검사한다.
    
    is로 어떤 타입인지 검사하면 그 변수가 원하는 타입으로 선언된 것 처럼 사용할 수 있다.(스마트 캐스트)
    
    스마트 캐스트는 is로 변수에 든 값의 타입을 검사한 다음 그 값이 바뀔 수 없는 경우에만 작동한다.
    
    원하는 타입으로 명시적으로 타입 캐스팅하려면 as 키워드를 사용해야 한다.
    

## if와 when의 분기에서 블록 사용
    
    블록의 마지막 식이 블록의 결과라는 규칙은 블록이 값을 만들어내야하는 경우 항상 성립한다.
    
    이 규칙은 함수에 대해서는 성립하지 않는다.(블록이 본문인 함수는 내부에 return문이 반드시 있어야하기 때문)
    
## for 루프
```kotlin
for (i in 1..10) {
    // 1부터 10까지
}

for (i in 1 until 10) {
    // 1부 9까지
}

for (i in 100 downTo 1 step 2) {
    // 100부터 2칸씩 아래로 
}
```

## map 이터레이션
```kotlin
val map = TreeMap<Integer, Integer>()

for ((key, value) in map) {
    // (키, 값) 쌍을 원소로 하는 컬렉션 이터레이션
}
```

## list 이터레이션
```kotlin
val list = arrayListOf(10, 20, 30)

for ((index, element) in list.withIndex()) {
    // 인덱스와 함게 컬렉션 이터레이션
}
```

## 예외 처리
- `throws` 절이 코드에 없다는 것이 자바 코드와 가장 큰 차이이다.
    - `throws`절 : 어떤 함수가 던질 가능성이 있는 예외나 그 함수가 호출한 다른 함수에서 발생할 수 있는 예외는 모두 `catch`로 처리해야 하며, 처리하지 않은 예외는 `throws` 절에 명시해야 한다.
```kotlin
fun readNumber(reader: BufferedReader): Int? {
    try {
        val line = reader.readLine()
        return Integer.parseInt(line)
    }
    catch (e: NumberFormatException) {
        return null
    }
    finally {
        reader.close()
    }
}
```
- 코틀린은 체크 예외와 언체크 예외을 구분하지 않는다.





