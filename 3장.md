[하준](https://www.notion.so/3-d20f911cb27c45608a2d15d67f49457c)

## 컬렉션
- 코틀린은 자신만의 컬렉션 기능을 제공하는 것이 아닌, 기존 자바 컬렉션을 활용한다.  
- 이는 자바 코드와 상호작용을 더 쉽게 만들어준다.
- 코틀린 컬렉션은 자바 컬렉션과 똑같은 클래스이지만, 자바보다 더 많은 기능을 쓸 수 있다. (ex. `last()`, `max()`)


### Set
```kotlin
val set = hashSetOf(1, 7, 53)
```


### List
```kotlin
val list  = arrayListOf(1, 7, 53)
```


### Map
```kotlin
val map = hashMapOf(1 to "one", 7 to "seven", 53 to "fifty-three")
```


## 디폴트 파라미터 값
- 함수의 디폴트 파리미터 값은 함수를 호출하는 쪽이 아니라 함수 선언쪽에 지정된다.
- 코틀린 함수를 자바에서 호출하는 경우에는 모든 인자를 명시해야한다.
 
 
## 이름 붙인 인자
코틀린으로 작성한 함수를 호출할 때는 함수에 전달하는 인자 중 일부 또는 전부 이름을 명시할 수 있다.
```kotlin
joinToString(collection, separator = " ", prefix = " ", postfix = ".")
```


### 최상위 함수
- 함수를 직접 소스 파일의 최상위 수준, 모든 다른 클래스의 밖에 위치하는 것
- 이 함수를 사용하고 싶으면, 해당 함수가 정의된 패키지를 임포트하면 된다.
- 코틀린 컴파일러가 생성하는 클래스의 이름은 최상위 함수가 들어있던 코틀린 소스 파일의 이름과 대응한다.
- 코틀린 파일의 모든 최상위 함수는 이 클래스의 `정적인 메소드` 가 된다.


### 최상위 프로퍼티
- 최상위 프로퍼티도 접근자 메소드를 통해 자바 코드에 노출된다.
- `정적 필드` 에 값을 저장한다.


### `const` 
- 자바의 `public static final` 과 같은 의미이다.
- 원시 타입과 String 타이브이 프로퍼티만 지정할 수 있다.
    
    
## 확장 함수
- 기존 자바 API를 재작성하지 않고도 코틀린이 제공하는 여러 편리한 기능을 사용하는 것
- 어떤 클래스의 멤버 메소드인 것처럼 호출할 수 있지만, 그 클래스 밖에 선언된 함수
- 확장 함수를 만들려면 추가하려는 함수 이름 앞에 확장할 클래스의 이름을 덧붙인다.
- 확장 함수는 `정적 메소드` 와 같은 특징을 가지므로, 확장 함수를 하위 클래스에서 오버라이드할 수는 없다.
- 클래스 이름을 `수신 객체 타입`, 확장 함수가 호출되는 대상이 되는 값(객체)을 `수신 객체` 라고 한다.

```kotlin
fun String.lastChar(): Char = this.get(this.length - 1)
// 수신 객체 타입: String 
// 수신 객체: this
```

```
>>> println("Kotlin".lashChar())
n
```

- 일반 메소드와 마찬가지로 확장 함수 본문에서도 this를 생략할 수 있다.
- 확장 함수 내부에서는 일반적인 인스턴스 메소드의 내부와 마찬가지로 수신 객체의 메소드나 프로퍼티를 바로 사용할 수 있다.
- 확장 함수 안에서는 클래스 내부에서만 사용할 수 있는 `private`, `protected` 멤버를 사용할 수 없다. => 확장 함수는 캡슐화를 깨지 않는다.
```kotlin
fun String.lashChar(): get(length - 1)
```

## 확장 함수 임포트
- 확장 함수를 정의하면 자동으로 모든 소스코드에서 그 함수를 사용할 수 있는 것은 아니다.
- 한 클래스에 같은 이름의 확장 함수가 둘 이상 있는 경우, 이름이 충돌할 수 있으므로 `import` 해주어야 한다.
- `as` 키워드를 사용하면 임포트한 클래스나 함수를 다른 이름으로 부를 수 있다.
  - 코틀린 문법상 확장 함수는 반드시 짧은 이름을 써야 한다.
  - 임포트할 때 이름을 바꾸는 것이 확장 함수 이름 충돌을 해결할 수 있는 유일한 방법이다.   
  
   
## 확장 함수로 유틸리티 함수 정의
- 확장 함수는 단지 정적 메소드 호출에 대한 문법적인 편의일 뿐이다.
- 클래스가 아닌 더 구체적인 타입을 수신 객체 타입으로 지정할 수 있다.
- <T> → <String>
    

## 확장함수는 오버라이드 할 수 없다(코틀린은 호출될 확장 함수를 정적으로 결정하기 때문)
- `정적` : 컴파일 시점
- `동적` : 실행 시점
- 확장 함수는 클래스 밖에 선언된다.
- 확장함수를 호출할 때 수신 객체로 지정한 변수의 정적 타입에 의해 어떤 확장 함수가 호출될지 결정될지, 그 변수에 저장된 객체의 동적인 타입에 의해 확장 함수가 결정되지 않는다.
- 확장 함수를 첫번째 인자가 수신객체인 정적 자바 메소드로 컴파일한다는 사실을 기억한다면 이런 동작을 쉽게 이해할 수 있다.  
- 확장한 함수와 멤버 함수의 이름과 시그니처가 같다면 멤버함수가 호출된다.(멤버함수의 우선순위가 더 높기 때문)
    
    
## 확장 프로퍼티
- 뒷받침하는 필드가 없어서 기본 게터 구현을 제공할 수 없으므로 최소한 게터는 꼭 정의 해야 한다.
- 초기화 코드에서 계산한 값을 담을 장소가 전혀 없으므로 초기화 코드도 쓸 수 없다.

```kotlin
val String.lastChar: Char
  get() = get(length - 1)
```

```kotlin
var StringBuilder.lastChar: Char
  get() = get(length - 1)
  set(value: Char) {
    this.setCharAt(length - 1, value)
  }
```

 
## 컬렉션 처리
     
- 가변 길이 인자 : vararg키워드를 사용하면 호출시 인자 개수가 달라질 수 있는 함수를 정의할 수 있다.
    
    자바 : 타입 뒤에 ...를 붙임
     
    배열을 그냥 넘기면 된다.
    
    코틀린 : 파라미터 앞에 vararg 변경자를 붙임
    
    기술적으로 스프레드 연산자가 작업을 해줌, 배열 앞에 *를 붙이기만 하면 된다.
    
- 중위 함수 호출
    
    중위 함수 호출을 사용하면 인자가 하나뿐인 메소드를 간편하게 호출할 수 있다.
    
    인자가 하나뿐인 일반 메소드나 확장함수에 중위 호출을 사용할 수 있다.
    
    함수를 중위호출에 사용하게 허용하고 싶으면 infix변경자를 함수 선언 앞에 추가해야 한다.
    
    구조분해선언 - Pair 인스턴스 외 다른 객체에도 구조 분해를 적용할 수 있다.(ex 2개 변수 초기화)
    
    to함수 - 타입과 관계없이 임의의 순서쌍을 만들 수 있다.
    
- 라이브러리 지원
    
    구조 분해 선언을 사용하면 복합적인 값을 분해해서 여러 변수에 나눠 담을 수 있다.
    

## 문자열과 정규식 다루기
    
- 마침표(.)는 모든 문자를 나타내는 정규식으로 해석된다.
    
- 정규식을 파라미터로 받는 함수는 String이 아닌 Regex 타입의 값을 받는다.
    
- 코틀린에서는 split함수에 전달하는 값의 타입의 따라 정규식이나 일반 텍스트 중 어느 것으로 문자열을 분리하는지 쉽게 알 수 있다.
    
- 정규식은 강력하지만 나중에 알아보기 힘든 경우가 많다.
    
- 3중 따옴표 문자열에서는 역슬래시(\)를 포함한 어떤 문자도 이스케이프할 필요가 없다.
    
- 3중 따옴표 문자열 안에 $를 넣어야한다면 문자열 템플릿 안에 ‘$’문자를 넣어야한다.
    

## 코드 다듬기 : 로컬 함수와 확장
    
- 코틀린에서는 함수에서 추출한 함수를 원 함수 내부에 중첩시킬 수 있다.
    
- 로컬 함수를 써서 코드를 더 깔끔하게 유지하면서 중복을 제거할 수 있다.


